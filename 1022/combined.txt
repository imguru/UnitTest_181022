// Google Test를 설치하고 빌드하는 방법
// 1. google test 소스를 다운로드 받는다.
// 2. 압축을 해지한다.
//   $ tar xvf release.tar.gz
// 3. 1) 제품 코드(SUT)
//    2) 구글 테스트 
//    3) 구글 테스트를 이용해서 만든 단위 테스트 프로그램

// googletest/scripts/fuse_gtest_files.py 스크립트를 이용하면, 파일을
// 두개의 파일로 합칠 수 있습니다.
//   $ ./fuse_gtest_files.py out
//   $ mv out/gtest ~/project
//   $ cd ~/project

//   $ cd gtest
//   $ g++ gtest-all.cc -c -I../
//   $ ar rcv gtest.a gtest-all.o
//   $ cd ..

//   $ g++ 1_start.cpp ./gtest/gtest.a -I. -lpthread 
//   $ ./a.out
//   : google test는 제품의 코드가 변경될 때마다, 매번 새로운 빌드를
//     수행해서 테스트 프로그램을 만드는 것이 좋습니다. 
//      => 정적 라이브러리를 사용하는 것을 권장합니다.
//      $ g++ gtest_main.cc -c -I../
//      $ ar rcv gtest_main.o gtest-all.o^C

#include "gtest/gtest.h"
#include <stdio.h>

// 용어(xUnit 표준)
//  TestCase class
//    - TestCase(TC)
//
// Google Test 용어
// 	TestCase
// 	  - Test

// TestCase 클래스를 만들지 않고, 바로 테스트를 만드는 방법
TEST(SampleTest, firstTest)
{
	printf("SampleTest.firstTest 수행되었음.\n");
	// 작성 중인 테스트는 반드시 실패해야 합니다. 
	

	// 테스트를 명시적으로 실패하는 방법.
	//  => 실패의 원인을 반드시 명시해야 한다.
	FAIL() << "작성 중입니다.";
}

#if 0
int main(int argc, char* argv[])
{
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
#endif















// 2_3A.cpp
// 단위 테스트를 구성하는 방법

// SUT
class Calculator {
public:
	double display() { return 0; }

	void enter(double value) {}
	void pressPlus() {}
	void pressMinus() {}
	void pressEqual() {}

	void calculate() {}
};

//----------------------------------
// 단위 테스트는 '3A'에 의해서 테스트를 구성합니다.
// 1. 객체를 생성하고, 필요한 경우에 적절하게 설정하고 준비한다.
//  -> Arrange
// 2. 객체에 작용을 가한다.
//  -> Act
// 3. 기대하는 바를 단언한다.
//  -> Assert
//
// 3A(TDD) / BDD
//  1. Given
//  2. When
//  3. Then
#include "gtest/gtest.h"

// 테스트의 이름은 테스트의 시나리오가 드러날 수 있도록 해야 한다.
//  : 테스트대상메소드_시나리오_기대값
// TEST(CalculatorTest, test1)
// => junit 5는 테스트 이름을 한글로 지을 수 있는 기능을 제공한다.
TEST(CalculatorTest, display_addingTwoPlusTwo_DisplaysFour)
{
	// Arrange
	Calculator* calc = new Calculator();

	// Act
	calc->enter(2);
	calc->pressPlus();
	calc->enter(2);
	calc->pressEqual();

	// Assert
	//  테스트 함수 안에서는 절대 반복문이나 조건문같은 제어 구문이
	//  발생하면 안됩니다. 
	//  1. 테스트 함수는 별도의 검증이 불가능하다.
	//  2. xUnit Test Framework은 검증을 위한 다양한 매크로를 제공하고
	//     있습니다. - 단언 매크로
	//  3. 실패의 이유를 명확하게 표현해야 합니다. 
	// ASSERT_EQ(calc->display(), 4);
	// 주의점: 인자의 순서가 중요합니다.
	//    ASSERT_EQ(expected-값, actual-값)
	ASSERT_EQ(4, calc->display()) << "when adding 2 + 2";

	#if 0
	if (calc->display() != 4)
		FAIL();
	else
		SUCCEED();
	#endif
}




















class Calculator {
public:
	double display() { return 0; }

	void enter(double value) {}
	void pressPlus() {}
	void pressMinus() {}
	void pressEqual() {}

	void calculate() {}
};

#include "gtest/gtest.h"

// Fixture
// 정의: xUnit Test Pattern에서는 SUT를 실행하기 위해 준비해야 하는
//       모든 것을 테스트 픽스쳐라고 합니다.
//     - 픽스쳐를 구성하는 모든 로직 부분을 '픽스쳐를 설치한다.'
//       라고 합니다.

// 1. 인라인 픽스쳐 설치
// : 모든 픽스쳐 설치에 관련된 코드를 테스트 함수 안에서 처리한다.
// 장점: 픽스쳐 설치와 검증 로직이 테스트 함수안에서 존재하기 때문에
//      인과 관계를 쉽게 파악할 수 있다. 
// 단점: 모든 테스트 함수 안에서 '코드 중복'이 발생합니다. 
//
// 테스트 냄새
//  : 테스트의 유지보수성을 떨어뜨린다.
TEST(CalculatorTest, addTest)
{
	Calculator* calc = new Calculator;

	calc->enter(2);
	calc->pressPlus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(4, calc->display());
}

TEST(CalculatorTest, minusTest)
{
	Calculator* calc = new Calculator;

	calc->enter(2);
	calc->pressMinus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(0, calc->display());
}


class Calculator {
public:
	double display() { return 0; }

	void enter(double value) {}
	void pressPlus() {}
	void pressMinus() {}
	void pressEqual() {}

	void calculate() {}
};
#include "gtest/gtest.h"

// 픽스쳐 설치 방법 2. 위임 설치
//  1. 동일한 픽스쳐를 가진 테스트 함수를 클래스로 묶는다.
//  2. 픽스쳐 설치에 관해 중복되는 코드를 함수로 제공한다.

// 테스트 케이스 클래스를 만드는 방법
// "테스트 케이스 클래스": 동일한 픽스쳐를 가지는 테스트의 집합
class CalculatorTest : public ::testing::Test {
	// private로 하면 테스트 함수에서 접근이 불가능합니다.
protected:
	// Test Utility Method
	//  : creation method
	//  테스트를 작성하면서, 코드의 중복이 발생하면, 반드시
	//  별도의 함수를 통해서 관리하는 것이 좋습니다. 
	Calculator* create() {
		return new Calculator;
	}
};

TEST_F(CalculatorTest, addTest)
{
	Calculator* calc = create();

	calc->enter(2);
	calc->pressPlus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(4, calc->display());
}

TEST_F(CalculatorTest, minusTest)
{
	Calculator* calc = create();

	calc->enter(2);
	calc->pressMinus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(0, calc->display());
}


class Calculator {
public:
	double display() { return 0; }

	void enter(double value) {}
	void pressPlus() {}
	void pressMinus() {}
	void pressEqual() {}

	void calculate() {}
};
#include "gtest/gtest.h"

// 방법 3. 암묵적 설치 / 해체 
//  => xUnit Test Framework 에서 제공하는 기능.
//    SetUp() / TearDown()
//     : 각각의 테스트를 수행하기 전에 수행되는 함수.
//  장점: 테스트 코드 중복을 제거하고, 꼭 필요하지 않은
//        상호작용을 캡슐화할 수 있다. 
//  단점: 픽스쳐 설치 코드가 함수 밖에 존재하기 때문에,
//        테스트 함수 만으로 코드를 이해하기 어렵다.

// Test Framework의 테스트 수행 흐름
//  => 신선한 픽스쳐 전략
// CalculatorTest* testcase = new CalculatorTest();
// testcase->SetUp();
// testcase->addTest();
// testcase->TearDown();
// delete testcase;
//
// CalculatorTest* testcase = new CalculatorTest();
// testcase->SetUp();
// testcase->minusTest();
// testcase->TearDown();
// delete testcase;

// xUnit Test Framework에서는 4단계 테스트 패턴을 이용합니다.
// 1단계: 테스트의 픽스쳐를 설치하거나, 실제 결과를 관찰하기 위해
//        필요한 것을 집어넣는다.
// 2단계: SUT와 상호 작용한다.
// 3단계: 기대 결과를 확인한다.
// 4단계: 테스트 픽스쳐를 해체해서, 테스트 시작 이전의 상태로 돌려놓는다. 
//
// 단위 테스트 품질 기준 3가지
// 1. 가독성
// 2. 유지보수성 
// 3. 신뢰성 

class CalculatorTest : public ::testing::Test {
public:
	~CalculatorTest()
	{
		printf("~CalculatorTest()\n");
	}

	CalculatorTest() 
	{
		printf("CalculatorTest()\n");
	}
protected:
	virtual void SetUp() {
		printf("SetUp()\n");
		calc = new Calculator();
	}

	virtual void TearDown() {
		printf("TearDown()\n");
		delete calc;
	}
	
	Calculator* calc;
};

TEST_F(CalculatorTest, addTest)
{
	printf("  addTest\n");
	calc->enter(2);
	calc->pressPlus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(4, calc->display());
}

TEST_F(CalculatorTest, minusTest)
{
	printf("  minusTest\n");
	calc->enter(2);
	calc->pressMinus();
	calc->enter(2);
	calc->pressEqual();

	ASSERT_EQ(0, calc->display());
}
// Google Test의 기능을 정리해봅시다. 
#include "gtest/gtest.h"

// 5. 테스트 비활성화
//  : 이름을 통해서 약속되어 있습니다.
//   테스트 케이스 클래스의 이름 또는 테스트 함수의 이름이
//   DISABLED_ 로 시작되면은 수행되지 않습니다. 
//    => 테스트를 주석으로 비활성화하면, 잊혀집니다. 
//    $ ./a.out --gtest_also_run_disabled_tests 
//      : 비활성화된 테스트도 같이 수행할 수 있습니다.

// 1. 단언 매크로
//   ASSERT_EQ, ASSERT_NE, ASSERT_LT, ASSERT_GT ...
// : 단언문은 하나라도 실패하면, 이후의 코드가 수행되지 않습니다.
//   => 하나의 테스트 안에는 하나의 단언문만 존재해야 한다.
//     "죽은 단언문"의 문제 때문에
//   => 하나의 테스트 안에 하나의 단언문만 있으면, 테스트가 너무
//     많아진다.
//      "유지보수성" 문제가 발생한다.
//   EXPECT_XX
// : 실패하면, 테스트는 실패하지만, 이후의 코드를 수행합니다.
TEST(GoogleTestSample, DISABLED_example1)
{
	int expected = 42;
	
	// ACT
	int actual1 = 30;
	int actual2 = 10;

	EXPECT_EQ(expected, actual1) << "Reason 1";
	EXPECT_EQ(expected, actual2) << "Reason 2";

#if 0
	ASSERT_EQ(expected, actual1) << "Reason 1";
	ASSERT_EQ(expected, actual2) << "Reason 2";
#endif
}

// 2. 문자열 비교
#include <string>
using namespace std;
// const char*

TEST(GoogleTestSample, DISABLED_example2) 
{
	string s1 = "Hello";
	string s2 = "Hello";
	
	ASSERT_EQ(s1, s2) << "s1 == s2";

	const char* s3 = "Hello";
	const char* s4 = s1.c_str();

	ASSERT_STREQ(s3, s4);
	// strcmp

	// ASSERT_EQ(s3, s4) << "s3 == s4";
	// s3 == s4
}

#include <math.h>
// 3. 부동 소수점 비교
//  : 동일한 값을 표현하는 여러가지 표현방식이 존재한다.
//  부동 소수점 타입은 절대 같거나 다름을 비교하면 안됩니다.
//   => 오차에 대한 계산을 통해 비교를 수행해야 합니다.
TEST(DISABLED_GoogleTestSample, example3)
{
	double expected = 0.7;

	double actual = 0.1 * 7;

#if 0
	if (fabs(actual - expected) < 0.0000001) {
		printf("same\n");
	}
#endif
	ASSERT_DOUBLE_EQ(expected, actual); // 4 ULP's
	// ASSERT_NEAR(expected, actual, 0.00000000001);
	ASSERT_NEAR(expected, actual, 0);

	// ASSERT_EQ(expected, actual);
}

// 4. 예외 테스트
void foo(const string& name)
{
#if 1
	if (name.empty())
		throw invalid_argument("name should not empty");
#endif
}

// foo에 빈문자열을 넘겼을 때, invalid_argument 예외가 발생해야 됩니다. 
TEST(GoogleTestSample, fooTest)
{
	string name = "";

	// EXPECT_THROW(foo(name), invalid_argument);
	
	// 예외가 발생하기만 하면 됩니다.
	EXPECT_ANY_THROW(foo(name));
}
#if 0
TEST(GoogleTestSample, fooTest)
{
	string name = "";

	try 
	{
		foo(name);
		FAIL() << "예외가 발생하지 않았습니다."; 
	}
	catch (invalid_argument& e)
	{
		SUCCEED();
	}
	catch (...)
	{
		FAIL() << "다른 예외가 발생하였습니다."; 
	}
}
#endif

















